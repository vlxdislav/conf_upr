### Задача 1
Исследование виртуальной стековой машины CPython.
Изучите возможности просмотра байткода ВМ CPython.

```bash
import dis

def foo(x):
    while x:
        x -= 1
    return x + 1

print(dis.dis(foo))
```
Опишите по шагам, что делает каждая из следующих команд (приведите эквивалентное выражение на Python):

```bash
11   0 LOAD_FAST                0 (x)
     2 LOAD_CONST               1 (10)
     4 BINARY_MULTIPLY
     6 LOAD_CONST               2 (42)
     8 BINARY_ADD
    10 RETURN_VALUE
```

```bash

LOAD_FAST 0 (x)
Загружает локальную переменную x на вершину стека.
Python-эквивалент: доступ к переменной x.

LOAD_CONST 1 (10)
Загружает константу 10 на вершину стека.
Python-эквивалент: константа 10.

BINARY_MULTIPLY
Умножает два верхних значения на стеке (в данном случае: x * 10), результат кладет на вершину стека.
Python-эквивалент: x * 10.

LOAD_CONST 2 (42)
Загружает константу 42 на вершину стека.
Python-эквивалент: константа 42.

BINARY_ADD
Складывает два верхних значения на стеке (в данном случае: (x * 10) + 42), результат кладет на вершину стека.
Python-эквивалент: (x * 10) + 42.

RETURN_VALUE
Возвращает значение, находящееся на вершине стека, как результат выполнения функции.
Python-эквивалент: возвращает (x * 10) + 42.

```
Python-эквивалент:

```bash
def foo(x):
    return (x * 10) + 42
```

### Задача 2
Что делает следующий байткод (опишите шаги его работы)? Это известная функция, назовите ее.
```bash
  5           0 LOAD_CONST               1 (1)
              2 STORE_FAST               1 (r)

  6     >>    4 LOAD_FAST                0 (n)
              6 LOAD_CONST               1 (1)
              8 COMPARE_OP               4 (>)
             10 POP_JUMP_IF_FALSE       30

  7          12 LOAD_FAST                1 (r)
             14 LOAD_FAST                0 (n)
             16 INPLACE_MULTIPLY
             18 STORE_FAST               1 (r)

  8          20 LOAD_FAST                0 (n)
             22 LOAD_CONST               1 (1)
             24 INPLACE_SUBTRACT
             26 STORE_FAST               0 (n)
             28 JUMP_ABSOLUTE            4

  9     >>   30 LOAD_FAST                1 (r)
             32 RETURN_VALUE
```

```bash
LOAD_CONST 1 (1) и STORE_FAST 1 (r)
Загружается константа 1 и сохраняется в локальную переменную r.
Python-эквивалент: r = 1.

LOAD_FAST 0 (n) и LOAD_CONST 1 (1)
Загружается локальная переменная n и константа 1.
Python-эквивалент: подготовка к сравнению n > 1.

COMPARE_OP 4 (>)
Выполняется сравнение n > 1.
Если результат ложный, происходит переход на инструкцию по адресу 30 (завершение функции).
Python-эквивалент: if n <= 1: return r.

LOAD_FAST 1 (r) и LOAD_FAST 0 (n)
Загружаются r и n для последующей операции умножения.
Python-эквивалент: r *= n.

INPLACE_MULTIPLY и STORE_FAST 1 (r)
Вычисляется произведение r * n, и результат сохраняется обратно в r.
Python-эквивалент: r *= n.

LOAD_FAST 0 (n) и LOAD_CONST 1 (1)
Загружается n и константа 1 для выполнения операции вычитания.
Python-эквивалент: n -= 1.

INPLACE_SUBTRACT и STORE_FAST 0 (n)
Вычисляется n - 1, и результат сохраняется обратно в n.
Python-эквивалент: n -= 1.

JUMP_ABSOLUTE 4
Переход обратно к началу цикла (инструкция на адресе 4).
Python-эквивалент: переход к началу цикла while n > 1.

LOAD_FAST 1 (r) и RETURN_VALUE
Загружается значение r и возвращается как результат функции.
Python-эквивалент: return r.

```
Этот байткод реализует вычисление факториала числа n. Эквивалентная функция на Python выглядит так:
```bash
def factorial(n):
    r = 1
    while n > 1:
        r *= n
        n -= 1
    return r
```

### Задача 3
Задача 1:
Python-функция:

```bash
def foo(x):
    return (x * 10) + 42
Для JVM (Java):
```
Аналогичная функция на Java:

```bash

int foo(int x) {
    return (x * 10) + 42;
}
```
Скомпилированный байткод JVM для этой функции:

```bash
0: iload_1         // Загрузка аргумента x
1: bipush 10       // Загрузка константы 10
3: imul            // Умножение x на 10
4: bipush 42       // Загрузка константы 42
6: iadd            // Сложение (x * 10) + 42
7: ireturn         // Возврат результата
```
Для .NET (C#):
Аналогичная функция на C#:
```bash
int Foo(int x) {
    return (x * 10) + 42;
}
```
Скомпилированный IL (Intermediate Language) код для этой функции:
```bash
IL_0000: ldarg.1    // Загрузка аргумента x
IL_0001: ldc.i4.s 10 // Загрузка константы 10
IL_0003: mul         // Умножение x на 10
IL_0004: ldc.i4.s 42 // Загрузка константы 42
IL_0006: add         // Сложение (x * 10) + 42
IL_0007: ret         // Возврат результата
```
Задача 2:
Python-функция:
```bash
def factorial(n):
    r = 1
    while n > 1:
        r *= n
        n -= 1
    return r
```
Для JVM (Java):
Аналогичная функция на Java:
```bash
int factorial(int n) {
    int r = 1;
    while (n > 1) {
        r *= n;
        n -= 1;
    }
    return r;
}
```
Скомпилированный байткод JVM для этой функции:
```bash

0: iconst_1         // Инициализация r = 1
1: istore_2         // Сохранение r
2: iload_1          // Загрузка n
3: iconst_1         // Загрузка константы 1
4: if_icmple 24     // Условие выхода: n <= 1
7: iload_2          // Загрузка r
8: iload_1          // Загрузка n
9: imul             // Умножение r * n
10: istore_2        // Сохранение результата в r
11: iload_1         // Загрузка n
12: iconst_1        // Загрузка константы 1
13: isub            // n -= 1
14: istore_1        // Сохранение результата в n
15: goto 2          // Переход к началу цикла
24: iload_2         // Загрузка r
25: ireturn         // Возврат результата
```

Для .NET (C#):
Аналогичная функция на C#:
```bash
int Factorial(int n) {
    int r = 1;
    while (n > 1) {
        r *= n;
        n -= 1;
    }
    return r;
}
```
Скомпилированный IL код для этой функции:
```bash
IL_0000: ldc.i4.1    // Инициализация r = 1
IL_0001: stloc.0     // Сохранение r
IL_0002: ldarg.1     // Загрузка n
IL_0003: ldc.i4.1    // Загрузка константы 1
IL_0004: ble.s IL_0014 // Условие выхода: n <= 1
IL_0006: ldloc.0     // Загрузка r
IL_0007: ldarg.1     // Загрузка n
IL_0008: mul         // Умножение r * n
IL_0009: stloc.0     // Сохранение результата в r
IL_000A: ldarg.1     // Загрузка n
IL_000B: ldc.i4.1    // Загрузка константы 1
IL_000C: sub         // n -= 1
IL_000D: starg.s 1   // Сохранение результата в n
IL_000F: br.s IL_0002 // Переход к началу цикла
IL_0014: ldloc.0     // Загрузка r
IL_0015: ret         // Возврат результата
```


